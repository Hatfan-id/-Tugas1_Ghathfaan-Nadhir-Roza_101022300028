import heapq

# Fungsi utama algoritma A*
def a_star_search(graph, heuristic, start, goal):
    # 1. Inisialisasi Struktur Data

    # open_list adalah priority queue (min-heap) untuk menyimpan simpul yang akan dieksplorasi.
    # Format: (f_score, node). Heapq selalu mengambil item dengan f_score terkecil.
    open_list = [(0, start)]  
    
    # came_from adalah dictionary untuk menyimpan node "parent" dari setiap node,
    # digunakan untuk merekonstruksi jalur terpendek setelah tujuan ditemukan.
    # Format: {node: parent_node}
    came_from = {}
    
    # g_score adalah dictionary untuk menyimpan biaya sebenarnya (jarak) dari 'start' ke setiap node.
    # Inisialisasi semua node dengan nilai tak terhingga (infinity).
    # Format: {node: actual_cost_from_start}
    g_score = {node: float('inf') for node in graph}
    g_score[start] = 0 # Biaya dari start ke start adalah 0
    
    # f_score adalah dictionary untuk menyimpan total perkiraan biaya: f(n) = g(n) + h(n).
    # Digunakan oleh priority queue.
    # Format: {node: total_estimated_cost}
    f_score = {node: float('inf') for node in graph}
    f_score[start] = heuristic[start] # f(start) = g(start) + h(start) = 0 + h(start)

    # 2. Loop Utama Pencarian
    while open_list:
        # Ambil (pop) node dengan f_score terendah dari priority queue.
        current_f, current_node = heapq.heappop(open_list)

        # 3. Kondisi Tujuan Tercapai
        if current_node == goal:
            # Jika node saat ini adalah tujuan, jalur telah ditemukan.
            path = []
            # Lakukan backtracking dari tujuan kembali ke start menggunakan came_from.
            while current_node in came_from:
                path.append(current_node)
                current_node = came_from[current_node]
            path.append(start)
            # Kembalikan jalur (dibalik agar dari start ke goal) dan total biaya (g_score[goal]).
            return path[::-1], g_score[goal]

        # 4. Eksplorasi Tetangga
        # Iterasi melalui setiap tetangga dari node saat ini.
        # graph[current_node] adalah dictionary {neighbor: weight}.
        for neighbor, weight in graph.get(current_node, {}).items():
            # Hitung g_score sementara (tentative) untuk tetangga ini.
            # g_score_baru = g_score node saat ini + biaya dari current ke neighbor
            tentative_g_score = g_score[current_node] + weight

            # Cek apakah jalur melalui current_node ini lebih baik (g_score lebih kecil)
            # dibandingkan g_score yang sudah tersimpan untuk neighbor.
            if tentative_g_score < g_score[neighbor]:
                # Jika lebih baik, simpan node saat ini sebagai parent-nya (jalur yang lebih baik).
                came_from[neighbor] = current_node
                # Perbarui g_score dengan biaya yang lebih rendah ini.
                g_score[neighbor] = tentative_g_score
                
                # Hitung f_score baru: g_score baru + h_score (heuristik) tetangga.
                f_score[neighbor] = g_score[neighbor] + heuristic[neighbor]
                
                # Masukkan tetangga ke open_list (priority queue) dengan f_score barunya.
                # Jika neighbor sudah ada di open_list, heapq akan memasukkan entri baru, 
                # dan entri lama (f_score lebih besar) akan diabaikan nanti.
                heapq.heappush(open_list, (f_score[neighbor], neighbor))

    # 5. Jika Loop Selesai dan Tujuan Belum Tercapai (open_list kosong)
    # Ini berarti tidak ada jalur yang mungkin.
    return None, float('inf') 

# --- DATA GRAF DAN HEURISTIK (Disesuaikan dengan Contoh Kasus) ---
# graph: Representasi koneksi antar node dan bobot sisi (jarak sebenarnya).
city_graph = {
    'A': {'B': 3, 'C': 5},
    'B': {'A': 3, 'D': 2},
    'C': {'A': 5, 'D': 4, 'F': 6},
    'D': {'B': 2, 'C': 4, 'E': 3},
    'E': {'D': 3, 'G': 1},
    'F': {'C': 6, 'G': 5},
    'G': {'E': 1, 'F': 5, 'H': 2},
    'H': {'G': 2}
}

# heuristic: Perkiraan jarak (h(n)) dari setiap node ke tujuan 'H'.
city_heuristic = {
    'A': 10, 'B': 8, 'C': 6, 'D': 7,
    'E': 4, 'F': 3, 'G': 1, 'H': 0
}

start_node = 'A'
goal_node = 'H'

# --- EKSEKUSI ---
shortest_path, total_cost = a_star_search(city_graph, city_heuristic, start_node, goal_node)

# --- OUTPUT HASIL ---
print("--- Hasil Pencarian Rute Terpendek dengan Algoritma A* ---")
if shortest_path:
    print(f"Titik Awal: *{start_node}*")
    print(f"Titik Tujuan: *{goal_node}*")
    print(f"Rute Terpendek Ditemukan: *{' -> '.join(shortest_path)}*")
    print(f"Total Biaya/Jarak (g(H)): *{total_cost}*")
else:
    print("Tidak ditemukan jalur dari A ke H.")

#
